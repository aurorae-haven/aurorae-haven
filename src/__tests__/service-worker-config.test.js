/**
 * Service Worker Configuration Tests
 * 
 * These tests verify that the service worker is correctly configured
 * to handle navigation requests and prevent 404 errors on page refresh.
 */

describe('Service Worker Configuration', () => {
  describe('NavigationRoute Configuration', () => {
    test('should have navigation fallback configured with relative path for production', () => {
      // This test verifies the configuration exists in vite.config.js
      // The actual service worker is generated by vite-plugin-pwa at build time
      
      // For production builds with BASE_URL='/aurorae-haven/'
      // navigateFallback must use simple 'index.html' to match the precached URL
      // Workbox's createHandlerBoundToURL() requires the exact precached URL
      // The service worker scope (/aurorae-haven/) handles base path resolution
      const productionConfig = {
        navigateFallback: 'index.html',
        hasAllowlist: true,
        hasDenylist: true
      }
      
      // Verify expected configuration structure
      expect(productionConfig.navigateFallback).toBe('index.html')
      expect(productionConfig.hasAllowlist).toBe(true)
      expect(productionConfig.hasDenylist).toBe(true)
    })

    test('should have navigation fallback configured with simple path for offline', () => {
      // For offline builds with BASE_URL='./'
      // navigateFallback must use simple 'index.html' to match the precached URL
      // Workbox's createHandlerBoundToURL() requires the exact precached URL
      // The service worker scope (./) handles base path resolution
      const offlineConfig = {
        navigateFallback: 'index.html',
        hasAllowlist: true,
        hasDenylist: true
      }
      
      // Verify expected configuration structure
      expect(offlineConfig.navigateFallback).toBe('index.html')
      expect(offlineConfig.hasAllowlist).toBe(true)
      expect(offlineConfig.hasDenylist).toBe(true)
    })
    
    test('should allow all navigation requests by default', () => {
      // The allowlist should match all paths: /.*/
      const allowlistPattern = /.*/
      
      const testPaths = [
        '/',
        '/home',
        '/schedule',
        '/aurorae-haven/',
        '/aurorae-haven/schedule',
        '/aurorae-haven/tasks'
      ]
      
      testPaths.forEach(path => {
        expect(allowlistPattern.test(path)).toBe(true)
      })
    })
    
    test('should deny requests for static files with extensions', () => {
      // The denylist should match files with extensions: /\/[^/?]+\.[^/]+$/
      const denylistPattern = /\/[^/?]+\.[^/]+$/
      
      const staticFiles = [
        '/assets/index.js',
        '/assets/styles.css',
        '/icon-192x192.svg',
        '/manifest.json'
      ]
      
      staticFiles.forEach(file => {
        expect(denylistPattern.test(file)).toBe(true)
      })
    })
    
    test('should deny requests starting with underscore', () => {
      // The denylist should match paths starting with /_: /^\/_/
      const denylistPattern = /^\/_/
      
      const deniedPaths = [
        '/_api/data',
        '/_internal/cache'
      ]
      
      deniedPaths.forEach(path => {
        expect(denylistPattern.test(path)).toBe(true)
      })
    })
    
    test('should not deny navigation routes without extensions', () => {
      // Navigation routes should NOT match the denylist pattern
      const denylistPattern = /\/[^/?]+\.[^/]+$/
      
      const navigationRoutes = [
        '/',
        '/home',
        '/schedule',
        '/aurorae-haven/',
        '/aurorae-haven/schedule',
        '/tasks',
        '/schedule?date=2024-01-01',
        '/tasks#list'
      ]
      
      navigationRoutes.forEach(route => {
        expect(denylistPattern.test(route)).toBe(false)
      })
    })
  })
  
  describe('Service Worker Registration', () => {
    test('should use vite-plugin-pwa generated service worker', () => {
      // Verify that we're using the auto-generated sw.js, not manual service-worker.js
      const expectedSWPath = 'sw.js'
      const notExpectedPath = 'service-worker.js'
      
      expect(expectedSWPath).toBe('sw.js')
      expect(notExpectedPath).not.toBe(expectedSWPath)
    })
    
    test('should register service worker with correct scope for production', () => {
      // For production (GitHub Pages), scope should be /aurorae-haven/
      const productionScope = '/aurorae-haven/'
      
      expect(productionScope).toMatch(/^\/.*\/$/)
      expect(productionScope).toBe('/aurorae-haven/')
    })
    
    test('should register service worker with correct scope for offline', () => {
      // For offline builds, scope should be ./
      const offlineScope = './'
      
      expect(offlineScope).toBe('./')
    })
  })
  
  describe('404.html Redirect Logic', () => {
    test('should correctly calculate base path from pathname', () => {
      // Simulate 404.html redirect logic
      const testCases = [
        { pathname: '/aurorae-haven/schedule', expected: '/aurorae-haven/' },
        { pathname: '/aurorae-haven/tasks', expected: '/aurorae-haven/' },
        { pathname: '/aurorae-haven/', expected: '/aurorae-haven/' },
        { pathname: '/schedule', expected: '/' },
        { pathname: '/tasks', expected: '/' },
        { pathname: '/', expected: '/' }
      ]
      
      testCases.forEach(({ pathname, expected }) => {
        const pathSegments = pathname.split('/').slice(0, -1)
        const basePath = pathSegments.join('/') + '/'
        expect(basePath).toBe(expected)
      })
    })
    
    test('should store full path including query and hash', () => {
      // The 404.html should store pathname + search + hash
      const mockLocation = {
        pathname: '/aurorae-haven/schedule',
        search: '?date=2024-01-01',
        hash: '#calendar'
      }
      
      const redirectPath = mockLocation.pathname + mockLocation.search + mockLocation.hash
      
      expect(redirectPath).toBe('/aurorae-haven/schedule?date=2024-01-01#calendar')
    })
  })
  
  describe('Integration: Service Worker + 404 Redirect', () => {
    test('should handle first visit/hard refresh flow correctly', () => {
      // Flow for FIRST VISIT or HARD REFRESH of /aurorae-haven/schedule on GitHub Pages:
      // (Service worker not active yet)
      // 1. GitHub Pages serves 404.html (no file exists at that path)
      // 2. 404.html stores path in sessionStorage and redirects to /aurorae-haven/
      // 3. React app loads at /aurorae-haven/
      // 4. RedirectHandler reads sessionStorage and navigates to /schedule
      // 5. Service worker installs and activates
      
      const firstVisitFlow = {
        step1: '404.html served by GitHub Pages',
        step2: 'Path stored in sessionStorage',
        step3: 'Redirect to base path',
        step4: 'React app loads and reads sessionStorage',
        step5: 'Navigate to correct route',
        step6: 'Service worker installs'
      }
      
      expect(firstVisitFlow.step1).toBeDefined()
      expect(firstVisitFlow.step2).toBeDefined()
      expect(firstVisitFlow.step3).toBeDefined()
      expect(firstVisitFlow.step4).toBeDefined()
      expect(firstVisitFlow.step5).toBeDefined()
      expect(firstVisitFlow.step6).toBeDefined()
    })

    test('should handle subsequent refresh with active service worker', () => {
      // Flow for SUBSEQUENT REFRESH of /aurorae-haven/schedule on GitHub Pages:
      // (Service worker is active)
      // 1. Browser requests /aurorae-haven/schedule
      // 2. Service worker intercepts navigation request
      // 3. Service worker serves /aurorae-haven/index.html (via navigateFallback)
      // 4. React Router handles /schedule route
      // 5. No 404 error!
      
      const subsequentRefreshFlow = {
        step1: 'Browser requests route',
        step2: 'Service worker intercepts',
        step3: 'Serve index.html via absolute navigateFallback',
        step4: 'React Router handles route',
        step5: 'Success - no 404!'
      }
      
      expect(subsequentRefreshFlow.step1).toBeDefined()
      expect(subsequentRefreshFlow.step2).toBeDefined()
      expect(subsequentRefreshFlow.step3).toBeDefined()
      expect(subsequentRefreshFlow.step4).toBeDefined()
      expect(subsequentRefreshFlow.step5).toBeDefined()
    })

    test('should verify navigateFallback path resolution for production', () => {
      // Verify that the navigateFallback uses simple 'index.html' for production
      // This is critical for the fix to work: must match the precached URL exactly
      // Workbox will resolve 'index.html' relative to the SW scope (/aurorae-haven/)
      const navigateFallback = 'index.html'
      const precachedUrl = 'index.html'
      
      // Both must match for navigation fallback to work
      expect(navigateFallback).toBe('index.html')
      expect(navigateFallback).toBe(precachedUrl)
    })

    test('should verify navigateFallback path resolution for offline', () => {
      // Verify that the navigateFallback uses simple 'index.html' for offline
      // This is critical for the fix to work: must match the precached URL exactly
      // Workbox will resolve 'index.html' relative to the SW scope (./)
      const navigateFallback = 'index.html'
      const precachedUrl = 'index.html'
      
      // Both must match for navigation fallback to work
      expect(navigateFallback).toBe('index.html')
      expect(navigateFallback).toBe(precachedUrl)
    })
  })
})
